



# 2.数据结构

## 2.1.数据结构（一）

![image-20211010151858961](E:\Typora\photo\image-20211010151858961.png)

![image-20211010152038893](E:\Typora\photo\image-20211010152038893.png)

### 2.1.1.单链表

**addToHead**



![image-20211010160214135](E:\Typora\photo\image-20211010160214135.png)

**add**

![image-20211010160314112](E:\Typora\photo\image-20211010160314112.png)

**remove**

![image-20211010160340146](E:\Typora\photo\image-20211010160340146.png)

**单链表【例子】**

```java
package com.axuan.chapter2.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class SinglyLinkedList {

    private static int N = 100010; // 数据规模为10w

    private static int head;// 表示头节点的下标
    private static int[] e = new int[N]; // 表示结点 i的值
    private static int[] ne = new int[N]; // 表示结点 i的next指针是多少
    private static int idx; // 表示存储当前节点已经使用结点的下一个结点

    // 初始化数据
    private static void init() {
        head = -1; // 没有头结点
        idx = 0; // 没有存入数据
    }

    // 将val插到头结点
    private static void addToHead(int val) {
        e[idx] = val; // 赋值
        ne[idx] = head; // 插入之前头结点的前面
        head = idx; // 更新头结点信息
        idx++; // idx向右移动
    }

    // 将下标是k的点后面的点删掉
    private static void remove(int k) {
        ne[k] = ne[ne[k]]; // 让下标为k的结点指向下个结点的下个结点
    }

    // 将val插入下标为k的点的后面
    private static void add(int k, int val) {
        e[idx] = val;
        ne[idx] = ne[k];
        ne[k] = idx;
        idx++;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(reader.readLine());

        init(); // 初始化操作

        // 进行m次操作
        while (m-- > 0) {
            String[] s = reader.readLine().split(" ");

            if (s[0].equals("H")) { // 插入头结点操作，不能使用 == ，要使用 equals()

                int val = Integer.parseInt(s[1]);
                addToHead(val);
            } else if (s[0].equals("I")) { // 普通插入操作
                int k = Integer.parseInt(s[1]);
                int val = Integer.parseInt(s[2]);
                add(k - 1, val); // 第k个结点的下标为k - 1, 所以插入到下标为k - 1结点的后面
            } else { // s[0] == "D",删除操作
                int k = Integer.parseInt(s[1]);

                if (k == 0) { // 题意：k = 0,删除头结点}
                    head = ne[head];
                } else
                    remove(k - 1); // 第k个结点的下标为k - 1,所以是删除到下标为k - 1后面的后面
            }
        }

        // 打印输出
        for (int i = head; i != -1; i = ne[i]) {
            System.out.print(e[i] + " ");
        }
    }
}
```

**单链表模板**

```java
	private static int N = 100010; // 数据规模为10w

    private static int head;// 表示头节点的下标
    private static int[] e = new int[N]; // 表示结点 i的值
    private static int[] ne = new int[N]; // 表示结点 i的next指针是多少
    private static int idx; // 表示存储当前节点已经使用结点的下一个结点

    // 初始化数据
    private static void init() {
        head = -1; // 没有头结点
        idx = 0; // 没有存入数据
    }

    // 将val插到头结点
    private static void addToHead(int val) {
        e[idx] = val; // 赋值
        ne[idx] = head; // 插入之前头结点的前面
        head = idx; // 更新头结点信息
        idx++; // idx向右移动
    }

    // 将下标是k的点后面的点删掉
    private static void remove(int k) {
        ne[k] = ne[ne[k]]; // 让下标为k的结点指向下个结点的下个结点
    }

    // 将val插入下标为k的点的后面
    private static void add(int k, int val) {
        e[idx] = val;
        ne[idx] = ne[k];
        ne[k] = idx;
        idx++;
    }
```

### 2.1.2.双链表

**init**

![image-20211010155845157](E:\Typora\photo\image-20211010155845157.png)

**add**

![image-20211010155952123](E:\Typora\photo\image-20211010155952123.png)

**remove**

![image-20211010160032952](E:\Typora\photo\image-20211010160032952.png)

**双链表【例子】**

```java
package com.axuan.chapter2.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class DoubleLinkedList {
    private static int N = 100010;
    private static int[] e = new int[N]; // e[]表示节点的值
    private static int[] l = new int[N]; // l[]表示节点的左指针
    private static int[] r = new int[N]; // r[]表示节点的右指针
    private static int idx; // idx表示当前用到了哪个节点

    // 初始化第1个插入节点下标为2，所以操作第k个数时都要+1 ！！
    private static void init() {
        // 左右边界指针，非节点
        r[0] = 1; // 指向第一个节点
        l[1] = 0; // 指向最后一个节点
        idx = 2;
    }

    // 在节点k的右边插入一个数
    private static void add(int k, int x) {
        e[idx] = x;
        l[idx] = k;
        r[idx] = r[k]; // 这边的 k 不加 1 ， 输入的时候 k+1 就好
        l[r[k]] = idx;
        r[k] = idx;
        idx++;
    }

    // 当然在 K 的左边插入一个数 可以再写一个 ， 也可以直接调用我们这个函数，在 k 的左边插入一个 数 等价于在 l[k] 的右边插入一个数 add(l[k],x)

    // 删除第k个点
    private static void remove(int k) {
        l[r[k]] = l[k];
        r[l[k]] = r[k];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(reader.readLine());

        init();

        while(m-- > 0) {
            String[] s = reader.readLine().split(" ");
            if (s[0].equals("L")) { // 最左边插入 就是在指向0的右边插入即可
                int x = Integer.parseInt(s[1]);
                add(0, x);
            } else if (s[0].equals("R")) { // 最右边插入 就是在执行1的那个点的右边插入即可
                int x = Integer.parseInt(s[1]);
                add(l[1], x);
            } else if(s[0].equals("D")) {
                int k = Integer.parseInt(s[1]);
                remove(k + 1);
            } else if(s[0].equals("IL")) {
                int k = Integer.parseInt(s[1]);
                int x = Integer.parseInt(s[2]);
                add(l[k + 1], x);
            } else if(s[0].equals("IR")) {
                int k = Integer.parseInt(s[1]);
                int x = Integer.parseInt(s[2]);
                add(k + 1, x);
            }
        }

        for (int i = r[0]; i != 1; i = r[i]) {
            System.out.print(e[i] + " ");
        }
    }
}
```

### 2.1.3.栈和队列

![image-20211010162614628](E:\Typora\photo\image-20211010162614628.png)

**模拟栈【例子】**

```java

package com.axuan.chapter2.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Stack {

    private static final int N = 100010;
    private static int[] stack = new int[N]; // 数据规模为10w
    private static int tt = 0; // 指向栈顶的指针

    private static void push(int val) {
        stack[++tt] = val;
    }

    private static void pop() {
        tt--;
    }

    private static boolean empty() {
        return tt == 0;
    }

    private static int query() {
        return stack[tt];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(reader.readLine());
        while (m-- > 0) {
            String[] s = reader.readLine().split(" ");
            if (s[0].equals("push")) {
                int x = Integer.parseInt(s[1]);
                push(x);
            } else if (s[0].equals("pop")) {
                pop();
            } else if (s[0].equals("empty")) {
                if (empty())
                    System.out.println("YES");
                else
                    System.out.println("NO");
            } else if (s[0].equals("query")) {
                System.out.println(query());
            }
        }
    }
}
```

**栈模板**

```java
	private static final int N = 100010;
    private static int[] stack = new int[N]; // 数据规模为10w
    private static int tt = 0; // 指向栈顶的指针

    private static void push(int val) {
        stack[++tt] = val;
    }

    private static void pop() {
        tt--;
    }

    private static boolean empty() {
        return tt == 0;
    }

    private static int query() {
        return stack[tt];
    }
```

**模拟队列【例子】**

```java
package com.axuan.chapter2.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Queue {
    private static int N = 100010;
    private static int[] q = new int[N];
    private static int hh = 0; // hh表示队头
    private static int tt = -1; // tt表示队尾的后一个位置

    // 向队尾插入一个数
    private static void push(int x) {
        q[++tt] = x;
    }

    // 从队头弹出一个数
    private static void pop() {
        hh++;
    }

    // 队头的值
    private static int query() {
        return q[hh];
    }

    // 判断队列是否为空
    private static boolean empty() {
        if (hh <= tt)
            return false;
        return true;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int m = Integer.parseInt(reader.readLine());

        while (m-- > 0) {
            String[] s = reader.readLine().split(" ");
            if (s[0].equals("push")) {
                int x = Integer.parseInt(s[1]);
                push(x);
            } else if (s[0].equals("pop")) {
                pop();
            } else if (s[0].equals("empty")) {
                if (empty())
                    System.out.println("YES");
                else
                    System.out.println("NO");
            } else if (s[0].equals("query")) {
                System.out.println(query());
            }
        }
    }

}
```

**队列模板**

```java
	private static int  N = 100010;
    private static int[] q = new int[N];
    private static int hh = 0; // hh表示队头
    private static int tt = -1; // tt表示队尾的后一个位置


    // 向队尾插入一个数
    private void push(int x) {
        q[++tt] = x;
    }

    // 从队头弹出一个数
    private void pop() {
        hh++;
    }

    // 队头的值
    private int query() {
        return q[hh];
    }

    // 判断队列是否为空
    private boolean empty() {
        if(hh <= tt) return false;
        return true;
    }
```

#### 2.1.3.1.单调栈

![image-20211010225146002](E:\Typora\photo\image-20211010225146002.png)

**暴力解法**

![image-20211010225407588](E:\Typora\photo\image-20211010225407588.png)

**利用栈来解决**

![image-20211010225555240](E:\Typora\photo\image-20211010225555240.png)

![image-20211010225644147](E:\Typora\photo\image-20211010225644147.png)

![在这里插入图片描述](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/20201211221031165.gif)

```java
package com.axuan.chapter2.demo01;

import java.util.Scanner;

/**
 * 单调栈
 */
public class MonotonousStack {
    private static int N = 100010;
    private static int[] stk = new int[N];
    private static int tt;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        while(n-- > 0) {
            int x = in.nextInt();
            while(tt != 0 && stk[tt] >= x) tt--; // 如果栈顶元素大于当前待入栈元素，则出栈
            if(tt == 0)
                System.out.print("-1 "); // 如果栈空，则没有比该元素小的值。
            else
                System.out.print(stk[tt] + " "); // 栈顶元素就是左侧第一个比它小的元素。
            stk[++tt] = x;
        }
    }
}
```

**单调栈模板**

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

#### 2.1.3.2.单调队列

**滑动窗口**

![image-20211010231614917](E:\Typora\photo\image-20211010231614917.png)

每次将滑动窗口中的最小值输出

![image-20211010232111419](E:\Typora\photo\image-20211010232111419.png)

```java
package com.axuan.chapter2.demo01;
/**
 * 滑动窗口
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class SlidingWindow {

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));
    static final int N = 1000010;
    static int[] q = new int[N]; // 队列数组，其中存放arr的下标值
    static int[] arr = new int[N];
    static int hh = 0, tt = -1; // tt指向栈顶元素

    public static void main(String[] args) throws IOException {
        String[] s1 = reader.readLine().split(" ");
        int n = Integer.parseInt(s1[0]);
        int k = Integer.parseInt(s1[1]);
        String[] s = reader.readLine().split(" ");
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(s[i]);
        }

        // 查找最小值
        for (int i = 0; i < n; i++) {
            // 判断队头是否已经滑出窗口，如果滑出窗口，则弹出队首元素，维护窗口大小补偿过k，每次值滑动一次，所以可以使用if
            if (hh <= tt && i - k + 1 > q[hh])
                hh++;
            // 寻找窗口中的最小值
            while (hh <= tt && arr[q[tt]] >= arr[i]) tt--;

            q[++tt] = i; // 将本轮下标添加到队列中
            // 保证满足窗口大小，比如窗口大小为3，不能此时只进入2个数字
            if(i + 1 >= k) log.write(arr[q[hh]] + " "); // 窗口内的最小值为队首元素
        }
        log.write("\n");
        hh = 0;
        tt = -1;
        // 查找最大值
        for (int i = 0; i < n; i++) {
            if(hh <= tt && i - k + 1 > q[hh]) hh++;
            while(hh <= tt && arr[q[tt]] <= arr[i]) tt--;
            q[++tt] = i;
            if (i + 1 >= k) log.write(arr[q[hh]] + " ");
        }
        // 关闭输入输出流
        log.flush();
        reader.close();
        log.close();
    }
    
}
```

**单调队列模板**

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

### 2.1.4.KMP字符串

**暴力解法**

![image-20211011234324127](E:\Typora\photo\image-20211011234324127.png)

**图示**

![image-20211011234548248](E:\Typora\photo\image-20211011234548248.png)

**具体分析**

[题解分析](https://www.acwing.com/solution/content/14666/)

**next[]数组的含义及手动模拟**

![image-20211012091735968](E:\Typora\photo\image-20211012091735968.png)

**匹配过程**

![image-20211012091807231](E:\Typora\photo\image-20211012091807231.png)

**求next数组的思路**

![image-20211013194014548](E:\Typora\photo\image-20211013194014548.png)



**实现代码**

```java
package com.axuan.chapter2.demo01;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * KMP字符串匹配
 */
public class KMP {
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

        // 模式串
        int n = Integer.parseInt(reader.readLine());
        String P = reader.readLine();
        char[] p = new char[n + 1];
        for (int i = 1; i <= n; i++) {
            p[i] = P.charAt(i - 1);
        }

        
        // 总串s
        int m = Integer.parseInt(reader.readLine());
        String S = reader.readLine();
        char[] s = new char[m + 1];
        for (int i = 1; i <= m; i++) {
            s[i] = S.charAt(i - 1);
        }

        // 构造前缀数组
        int[] prefix = new int[n + 1];
        for (int i = 2, j = 0; i <= n; i++) {
            // i从2开始，因为prefix[1]肯定为0
            while(j != 0 && p[i] != p[j + 1])
                j = prefix[j];
            if(p[i] == p[j + 1])
                j++;
            prefix[i] = j;
        }

        // kmp匹配
        for (int i = 1, j = 0; i <= m; i++) {
            while (j != 0 && s[i] != p[j + 1]) {
                j = prefix[j]; // s[i] != p[j + 1]即不匹配，则往后移动
            }
            if (s[i] == p[j + 1])
                j++; // 匹配时将j++进行了下一个字符得匹配
            if (j == n) { // 匹配n字符了即代表完全匹配了
                writer.write(i - n + " ");
                j = prefix[j]; // 完全匹配后继续搜索
            } 
        }

        writer.flush(); // 所有write下的内容，会先存在writer中，当启用flush以后，会输出存在其中的内容。如果没有调用flush，则不会将writer中的内容进行输出。
        writer.close();
        reader.close();
    }
    
}
```

**kmp模板**

```cpp
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

## 2.2.Week2-习题课

### 2.2.1.双指针-数组元素的目标和

![image-20211014103719851](E:\Typora\photo\image-20211014103719851.png)

**图示**

![image-20211014103805179](E:\Typora\photo\image-20211014103805179.png)

**实现代码**

```java
package com.axuan.chapter2.test01;

import java.util.Scanner;

public class TargetSumOfArrayElements{

    static int N = 100010;
    
    public static void main(String[] args) {
        int[] a = new int[N];
        int[] b = new int[N];
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int x = in.nextInt();

        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }

        for (int i = 0; i < m; i++) {
            b[i] = in.nextInt();
        }

        for (int i = 0, j = m - 1; i < n; i++) {
            while(j >= 0 && a[i] + b[j] > x) j--;
            if (a[i] + b[j] == x) {
                System.out.println(i + " " + j);
                break;
            }
        }

    }

}
```

## 2.3.数据结构（二）

### 2.3.1.Trie

![image-20211015104302070](E:\Typora\photo\image-20211015104302070.png)

**图示**

![image-20211015104414271](E:\Typora\photo\image-20211015104414271.png)

![image-20211015104742238](E:\Typora\photo\image-20211015104742238.png)

**代码实现**

```java
package com.axuan.chapter2.demo02;

import java.util.Scanner;

public class Trie {
    static int N = 100010;
    static int son[][] = new int[N][26]; // 存储子节点的位置，分支最多26条
    static int cnt[] = new int[N]; // 存储以某节点结尾的字符串个数（同时也起标记作用）
    static int idx; // idx表示当前要插入的节点是第几个，每创建一个节点值+1，下标0有两个含义；既是根节点又是空节点
   
    private static void insert(char[] str) {
        int p = 0; // 类似指针，指向当前节点
        for (int i = 0; i < str.length; i++) {
            int u = str[i] - 'a'; // 将字母转换为数字
            if (son[p][u] == 0) son[p][u] = ++idx; // 该节点不存在，创建节点
            p = son[p][u]; // 使p指针指向下一个节点
        }
        cnt[p]++; // 结束时的标记，也是记录以此节点结束的字符串个数
    }

    private static int query(char[] str) {
        int p = 0;
        for (int i = 0; i < str.length; i++) {
            int u = str[i] - 'a';
            // 如果不存在在这个子节点的话，说明集合中不存在这个单词
            if (son[p][u] == 0) return 0;
            // 否则的话走过去
            p = son[p][u];
        }
        return cnt[p]; // 返回以p结尾的单词数量
    }
    
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        while(n-- > 0) {
            String op = in.next();
            String s = in.next();
            if ("I".equals(op)) {
                insert(s.toCharArray());
            } else if ("Q".equals(op)) {
                System.out.println(query(s.toCharArray()));
            }
        }
    }
    
}
```

**Trie模板**

```cpp
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

### 2.3.2.并查集

![image-20211015111518442](E:\Typora\photo\image-20211015111518442.png)

![image-20211015112433480](E:\Typora\photo\image-20211015112433480.png)![image-20211015112435613](E:\Typora\photo\image-20211015112435613.png)

**代码实现**

```java
package com.axuan.chapter2.demo02;

import java.util.Scanner;

/**
 * 并查集
 */
public class CheckAndSet {
    static int N = 100010;
    static int[] p = new int[N];

    // 使用了路径压缩
    private static int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();

        for (int i = 0; i < n; i++) {
            p[i] = i;
        }

        String opt;
        int a, b;
        while (m-- > 0) {
            opt = in.next();
            a = in.nextInt();
            b = in.nextInt();
            if (opt.equals("M"))
                p[find(a)] = find(b);
            else {
                if (find(a) == find(b))
                    System.out.println("Yes");
                else
                    System.out.println("No");
            }
        }
    }
}
```

**模板**

```cpp
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
	{
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
// 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

#### 2.3.2.1.连通块中点的数量

相较于并查集多了一个size数组用来存储连通块中点的数量，它只在根连通点中记录数量

![image-20211015143028744](E:\Typora\photo\image-20211015143028744.png)

```java
package com.axuan.chapter2.demo02;

import java.util.Scanner;

public class NumberOfConnectedBlockMidpoints {
    static int N = 100010;
    static int[] p = new int[N];
    static int[] size = new int[N];

    private static int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();

        for (int i = 0; i < n; i++) {
            p[i] = i;
            size[i] = 1;
        }

        String opt;
        int a, b;
        while (m-- > 0) { 
            opt = in.next();
            if (opt.equals("C")){
                a = in.nextInt();
                b = in.nextInt();
                if (find(a) == find(b)) continue; // 如果说，两个点已经在一个连通块汇总就不需要连线了
                size[find(b)] += size[find(a)];  // 应该先将点的数量加在一起，然后在合并
                p[find(a)] = find(b);
            } else if(opt.equals("Q1")){
                a = in.nextInt();
                b = in.nextInt();
                if (find(a) == find(b))
                    System.out.println("Yes");
                else
                    System.out.println("No");
            } else {
                a = in.nextInt();
                System.out.println(size[find(a)]);
            }
        }
    }
}
```

### 2.3.3.堆

![image-20211015143416287](E:\Typora\photo\image-20211015143416287.png)

![image-20211015143507832](E:\Typora\photo\image-20211015143507832.png)

![image-20211015143605136](E:\Typora\photo\image-20211015143605136.png)

![image-20211015160719630](E:\Typora\photo\image-20211015160719630.png)

数组从1开始存储，是为了计算方便，因为计算 2*n的时候，0很特殊。

**代码实现**

```java
package com.axuan.chapter2.demo02;

import java.util.Scanner;

public class HeapSort {
    static int N = 100010;
    static int[] h = new int[N];
    static int size;

    private static void down(int u) {
        int t = u;
        if (u * 2 <= size && h[u * 2] < h[t])
            t = u * 2;
        if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t])
            t = u * 2 + 1;
        if (u != t) {
            int temp = h[u];
            h[u] = h[t];
            h[t] = temp;
            down(t);
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        for (int i = 1; i <= n; i++) {
            h[i] = in.nextInt();
        }

        size = n;
        for (int i = (n / 2); i >= 0; i--) {
            down(i);
        }

        while (m-- > 0) {
            System.out.print(h[1] + " ");
            h[1] = h[size];
            size--;
            down(1);
        }
    }
}
```

**算法模板**

```cpp
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

#### 2.3.3.1.模拟堆

![image-20211015162543264](E:\Typora\photo\image-20211015162543264.png)

![image-20211015162703027](E:\Typora\photo\image-20211015162703027.png)

```java
package com.axuan.chapter2.demo02;
/**
 * 模拟堆
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

public class SimulateHeap {
    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
    static int[] h;
    static int[] ph; // 存放第k个插入点的下标
    static int[] hp; // 存放堆中的插入的次数
    static int size;

    private static void heapSwap(int u,int v) {
        swap(h, u, v);
        swap(hp, u, v);
        swap(ph, hp[u], hp[v]);
    }

    private static void swap(int[] a, int u, int v) {
        int tmp = a[u];
        a[u] = a[v];
        a[v] = tmp;
    }

    private static void down(int u) {
        int t = u;
        if(u * 2 <= size && h[t] > h[u * 2]) t = u * 2;
        if(u * 2 + 1 <= size && h[t] > h[u * 2 + 1]) t = u * 2 + 1;
        if(u != t) {
            heapSwap(u, t);
            down(t);
        }
    }

    private static void up(int u) {
        if(u / 2 > 0 && h[u] < h[u/2]) {
            heapSwap(u, u / 2);
            up(u / 2);
        }
    }

    public static void main(String[] args) throws IOException {
        int n = Integer.parseInt(reader.readLine());
        h = new int[n + 1];
        ph = new int[n + 1];
        hp = new int[n + 1];
        size = 0;
        int m = 0; // m用来记录插入的数的个数
        while(n-- > 0) {
            String[] s = reader.readLine().split(" ");
            String op = s[0];
            if ("I".equals(op)) {
                int x = Integer.parseInt(s[1]);
                m++;
                size++;
                h[size] = x;
                ph[m] = size; // 插入的时候要维护这两个指针数组
                hp[size] = m;
                // down(size);
                up(size);
            } else if("PM".equals(op)) 
                writer.write(h[1] + "\n");
            else if("DM".equals(op)) {
                heapSwap(1, size);
                size--;
                down(1);
            } else if("D".equals(op)) {
                int k = Integer.parseInt(s[1]);
                int u = ph[k]; // 这里需要用u来保存第k个插入点的下标
                heapSwap(u, size);
                size--;
                up(u);
                down(u);
            } else if("C".equals(op)) {
                int k = Integer.parseInt(s[1]);
                int x = Integer.parseInt(s[2]);
                h[ph[k]] = x;
                down(ph[k]);
                up(ph[k]);
            }
        }
        writer.flush();
        writer.close();
        reader.close();
    }
}
```

## 2.4.Week3-习题课

### 2.4.1.Trie-最大异或对

**暴力解法**

![image-20211017154148445](E:\Typora\photo\image-20211017154148445.png)

**图示**

![image-20211017154250995](E:\Typora\photo\image-20211017154250995.png)

**代码实现**

```java
package com.axuan.chapter2.test02;

import java.util.Scanner;

public class MaximumXorPair {

    static int N = 100010, M = 31 * N;
    static int[] a = new int[N];
    static int[][] son = new int[M][2];
    static int idx;

    private static void insert(int x) {
        int p = 0;
        for (int i = 30; i >= 0; i--) {
            int u = x >> i & 1;
            if (son[p][u] == 0)
                son[p][u] = ++idx;
            p = son[p][u];
        }
    }

    private static int query(int x) {
        int p = 0, res = 0;
        for (int i = 30; i >= 0; i--) {
            int u = x >> i & 1;
            if (son[p][1 - u] != 0) { // 走相反的那条路，因为这样异或下来是1，结果才是最大的
                p = son[p][1 - u];
                res = res * 2 + (1 - u); // * 2相当于左移一位
            } else { // 如果没有，则走有的路
                p = son[p][u];
                res = res * 2 + u;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }

        int res = 0;
        for (int i = 0; i < n; i++) {
            insert(a[i]);
            int t = query(a[i]); // t是查下来的与a[i]最大异或数值
            res = Math.max(res, a[i] ^ t); // a[i]与t异或之后的结果和最大值进行判断
        }

        System.out.println(res);
    }
}
```

### 2.4.2.并查集-食物链

**图示**

![image-20211017161925014](E:\Typora\photo\image-20211017161925014.png)

为满足同类情况下：

![image-20211017162926671](E:\Typora\photo\image-20211017162926671.png)

为满足X吃Y情况下：

![image-20211017163112485](E:\Typora\photo\image-20211017163112485.png)

```java
package com.axuan.chapter2.test02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class FoodChain {
    static int N = 50010;
    static int[] p = new int[N];
    static int[] d = new int[N];

    private static int find(int x) {
        if (p[x] != x) {
            int t = find(p[x]);
            d[x] += d[p[x]];
            p[x] = t;
        }
        return p[x];
    }

    public static void main(String[] args) throws NumberFormatException, IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] s = reader.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int m = Integer.parseInt(s[1]);

        for (int i = 1; i <= n; i++) {
            p[i] = i;
        }

        int res = 0;
        String[] str;
        int t, x, y;
        while(m-- > 0) {
            str = reader.readLine().split(" ");
            t = Integer.parseInt(str[0]);
            x = Integer.parseInt(str[1]);
            y = Integer.parseInt(str[2]);

            if (x > n || y > n) res++; // 所比较的动物数量大于总数，则为假话
            else {
                int px = find(x), py = find(y);
                if (t == 1) { // 判断是否同类
                    if(px == py && (d[x] - d[y]) % 3 != 0){
                        res++; // 在同一集合中，但是距离之差取模3不为0，则不是同类，为假话
                    } 
                    else if (px != py) { // 不在同一个集合中【这样做，是因为它们之间无法比较，因此让它们进行操作，尽量使其满足真】
                        p[px] = py; // 合并成一个集合
                        d[px] = d[y] - d[x]; // 为了让它们属于同类，构造出符合条件的距离
                    }
                } else { // 判断是否存在吃的关系
                    if(px == py && (d[x] - d[y] - 1) % 3 != 0){
                        res++; // 在同一集合中，但是距离之差取模3不为1，则不是吃的关系，为假话
                    } 
                    else if(px != py) {
                        p[px] = py; // 合并成一个集合
                        d[px] = d[y] + 1 -d[x]; // 为了让它们满足吃的关系，构造出符合条件的距离
                    }
                }
            }
         }
        System.out.println(res);
    }

}
```

## 2.5.数据结构（三）

### 2.5.1.哈希表

![image-20211019103320353](E:\Typora\photo\image-20211019103320353.png)

#### 2.5.1.1.模拟散列表

##### 2.5.1.1.1.拉链法

![4.jpg](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/2675_9b33804c58-4.jpg)

```java
package com.axuan.chapter2.demo03;

import java.util.Scanner;

/**
 * 拉链法
 */
public class ZipperMethod {
    static int N = 100003; // 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度
    // 相当于邻接表
    static int[] h = new int[N]; // 拉链数组
    static int[] e = new int[N]; // 地址为N的设置
    static int[] ne = new int[N]; // 地址为N的下一个节点地址
    // 设0为空，地址从1开始
    static int idx = 1; // 节点地址

    private static boolean find(int x) {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != 0 ; i = ne[i]) {
            if(e[i] == x) {
                return true;
            }
        }
        return false;
    }

    private static void insert(int x) {
        // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx++;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int m = in.nextInt();
        while(m-- > 0) {
            String op = in.next();
            int x = in.nextInt();
            if("I".equals(op)) {
                insert(x);
            } else {
                System.out.println(find(x) == false ? "No" : "Yes");
            }
        }
    }
    
}
```



##### 2.5.1.1.2.开放寻址法

![5.jpg](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/2675_a204a13158-5.jpg)

```java
package com.axuan.chapter2.demo03;

import java.util.Scanner;

/**
 * 开放地址法
 */
public class OpenAddressMethod {
     // 开放寻址法一般开 数据范围的2~3倍，这样大概率就没有冲突了
    static int N = 200003; // 大于数据范围的第一个质数
    static Integer[] h = new Integer[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    private static int find(int x) {
        int k = (x % N + N) % N;
        while (h[k] != null && h[k] != x) {
            k++;
            if (k == N) k = 0; // 找到末尾位置，如果还没有找到，置为0，从头开始找
        }
        return k;
    }

    public static void main(String[] args) {
        for (int i = 0; i < h.length; i++) {
            h[i] = null;
        }
        Scanner in = new Scanner(System.in);
        int m = in.nextInt();
        while(m-- > 0) {
            String op = in.next();
            int x = in.nextInt();
            if("I".equals(op)) {
                h[find(x)] = x;
            } else {
                System.out.println(h[find(x)] == null ? "No" : "Yes");
            }
        }
    }
}
```

**模板**

```cpp
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }
    
(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

#### 2.5.1.2.字符串哈希

![image-20211019145455278](E:\Typora\photo\image-20211019145455278.png)

![image-20211019145558463](E:\Typora\photo\image-20211019145558463.png)



**代码实现**

```java
package com.axuan.chapter2.demo03;

import java.io.IOException;
import java.util.Scanner;

/**
 * 字符串哈希
 */
// 使用场景：两个字符串的子串是否相同
public class StringHash {
    static int N = 100010;
    static int P = 131; // P = 131 或 13331 Q = 2^64,在99%的情况下不会出现冲突
    static long[] p = new long[N];
    // 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
    static long[] h = new long[N]; // h[i]前i个字符的hash值

    private static long get(int l, int r) {
        return h[r] - h[l - 1] * p[r - l + 1];
    }

    public static void main(String[] args) throws IOException {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        String str = " " + in.next();
        char[] s = str.toCharArray();
        p[0] = 1; // 要给p赋初值，否则默认会赋0
        for (int i = 1; i <= n; i++) {
            p[i] = p[i - 1] * P;
            h[i] = h[i - 1] * P + s[i]; // 前缀和求整个字符串的哈希值
        }

        while (m-- > 0) {
            int l1 = in.nextInt();
            int r1 = in.nextInt();
            int l2 = in.nextInt();
            int r2 = in.nextInt();
            if (get(l1, r1) == get(l2, r2))
                System.out.println("Yes");
            else
                System.out.println("No");
        }
    }

}
```





**模板**

```cpp
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

### 2.5.2.STL

```cpp
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
    
queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器

map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```



## 2.6.课后习题

### 2.6.1.栈-表达式计算

```java
package com.axuan.chapter2.test3;

/**
 * @author ZhouXuan
 * @version 1.0
 * @date 2021/10/26 19:54
 */

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Stack;

public class ExpressionCalculation {

    static Map<Character, Integer> h = new HashMap<>();

    static Stack<Integer> num = new Stack<>();
    static Stack<Character> op = new Stack<>();

    // 优先级表
    static {
        h.put('+', 1);
        h.put('-', 1);
        h.put('*', 2);
        h.put('/', 2);
        h.put('(', -1);
    }

    // 求值
    private static void eval() {
        int a = num.peek(); // 第二个操作数
        num.pop();

        int b = num.peek(); // 第一个操作数
        num.pop();

        char p = op.peek(); // 运算符
        op.pop();

        int r = 0; // 结果

        // 计算结果
        if (p == '+')
            r = b + a;
        if (p == '-')
            r = b - a;
        if (p == '*')
            r = b * a;
        if (p == '/')
            r = b / a;

        num.push(r); // 结果入栈

    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str; // 读入表达式
        str = in.next();

        char[] s = str.toCharArray();
        for (int i = 0; i < s.length; i++) {
            if (Character.isDigit(s[i])) { // 数字入栈
                int x = 0, j = i; // 计算数字
                while (j < s.length && Character.isDigit(s[j])) {
                    x = x * 10 + s[j] - '0';
                    j++;
                }
                num.push(x); // 数字入栈
                i = j - 1;
            }
            // 左括号无优先级，直接入栈
            else if (s[i] == '(') { // 左括号入栈
                op.push(s[i]);
            }
            // 括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的
            else if (s[i] == ')') { // 右括号
                while (op.peek() != '(') { // 一直计算到左括号
                    eval();
                }
                op.pop(); // 左括号出栈
            } else {
                while (op.size() > 0 && h.get(op.peek()) >= h.get(s[i])) // 待入栈运算符优先级低，则先计算
                    eval();
                op.push(s[i]);
            }
        }

        while (op.size() > 0)
            eval(); // 剩余的进行计算
        System.out.println(num.peek()); // 输出结果
    }

}
```

