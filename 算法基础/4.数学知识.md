# 4.数学知识

![image-20211106160944626](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106160944626.png)

## 4.1.数学知识（一）

### 4.1.1.质数

![image-20211106161349526](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106161349526.png)

#### 4.1.1.1.试除法判定质数

![image-20211106163713195](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106163713195.png)

![image-20211106161445958](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106161445958.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 试除法判断质数
 */
public class JudgePrimeNumber {
    static int n;

    private static boolean is_prime(int x) {
        if (x < 2) return false;
        for (int i = 2; i <= x / i; i++) {
            if (x % i == 0){
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();

        int a;
        while (n-- > 0) {
            a = in.nextInt();
            if(is_prime(a)) System.out.println("Yes");
            else System.out.println("No");
        }
    }
}
```

**算法模板**

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```

#### 4.1.1.2.试除法分解质因数

![image-20211106163742370](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106163742370.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 试除法分解质因数
 */
public class DecomposedPrimeFactor {

    private static void divide(int n) {
        for (int i = 2; i <= n / i; i++) {
            if (n % i == 0) {
                int s = 0;
                while (n % i == 0) {
                    n /= i;
                    s++;
                }
                System.out.println(i + " " + s);
            }
        }

        if (n > 1) System.out.println(n + " " + 1);
        System.out.println();
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        while (n-- > 0) {
            int x = in.nextInt();
            divide(x);
        }
    }

}
```

**算法模板**

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

#### 4.1.1.3.朴素筛法求素数

![image-20211106170125466](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106170125466.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 朴素筛法求素数
 */
public class ScreenPrimeNumber {
    static int N = 1000010;

    static int[] primes = new int[N];
    static int cnt;
    static boolean[] st = new boolean[N];

    private static void get_primes(int n) {
        for (int i = 2; i <= n; i++) {
            if (!st[i]) {
                primes[cnt++] = n;
            }

            for (int j = i + i; j <= n; j += i) { // 筛选掉是i的倍数的数
                st[j] = true;
            }
        }
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        get_primes(n);

        System.out.println(cnt);
    }
}
```

**优化后的**

![image-20211106171326163](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106171326163.png)

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 朴素筛法求素数
 */
public class ScreenPrimeNumber {
    static int N = 1000010;

    static int[] primes = new int[N];
    static int cnt;
    static boolean[] st = new boolean[N];

    private static void get_primes(int n) {
        for (int i = 2; i <= n; i++) {
            if (!st[i]) {
                primes[cnt++] = n;
                for (int j = i + i; j <= n; j += i) { // 筛选掉是i的倍数的数
                    st[j] = true;
                }
            }
        }
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        get_primes(n);

        System.out.println(cnt);
    }
}
```

**算法模板**

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

#### 4.1.1.4.线性筛法求素数

![image-20211106172457288](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211106172457288.png)

**网络上的解释**

![image-20211107152513537](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107152513537.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 线性筛法
 */
public class ScreenPrimeNumber2 {
    static int N = 1000010;

    static int[] primes = new int[N];
    static int cnt;
    static boolean[] st = new boolean[N];

    private static void get_primes(int n) {
        for (int i = 2; i <= n; i++) {
            if(!st[i]) primes[cnt++] = i;
            for (int j = 0; primes[j] <= n / i; j++) {
                st[primes[j] * i] = true;
                if(i % primes[j] == 0) break; // primes[j]一定是i的最小质因子
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        get_primes(n);

        System.out.println(cnt);
    }
}
```

**算法模板**

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

### 4.1.2.约数

#### 4.1.2.1.试除法求所有约数

![image-20211107093929567](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107093929567.png)

**代码实现**

```java
// package com.axuan.chapter4.demo01;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

/**
 * 试除法求一个数的所有约数
 */
public class Main {

    private static List<Integer> get_divisors(int n) {
        List<Integer> res = new ArrayList<Integer>();

        for (int i = 1; i <= n / i; i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i); // 为了防止放入同一个数，比如某个数的平方
            }
        }

        Collections.sort(res);
        return res;
    }
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        while (n-- > 0) {
            int x = in.nextInt();
            List<Integer> res = get_divisors(x);
            for(Integer num : res) {
                System.out.print(num + " ");
            }
            System.out.println();
        }
    }
}
```

**算法模板**

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

#### 4.1.2.2.约数个数和约数之和

##### 4.1.2.2.1.约数个数

![image-20211107095356645](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107095356645.png)

![image-20211107095408774](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107095408774.png)

**图示**

![image-20211107100053800](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107100053800.png)

分别分解每一个数，然后将指数累加起来

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * 约数个数
 */
public class TheNumberOfFew {
     static int mod = (int) (1e9 + 7);
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        Map<Integer,Integer> primes = new HashMap();
        while (n-- > 0) {
            int x = in.nextInt();

            for (int i = 2; i <= x / i; i++) {
                while (x % i == 0) {
                    x /= i;
                    primes.put(i, primes.getOrDefault(i, 0) + 1);
                }
            }

            if(x > 1) primes.put(x, primes.getOrDefault(x, 0) + 1);
        }

        

        long res = 1;  // 这里一定要是long类型，否则int会越界
        for (int a : primes.values()) {
            res = res * (a + 1) % mod;
        }

        System.out.println(res);
    }
}
```

##### 4.1.2.2.2.约数之和

![image-20211107095722699](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107095722699.png)

**图示**

![image-20211107102921438](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107102921438.png)



**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

/**
 * 约数之和
 */
public class TheSumOfFew {
    static int mod = (int) (1e9 + 7);
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        Map<Integer,Integer> primes = new HashMap();
        while (n-- > 0) {
            int x = in.nextInt();

            for (int i = 2; i <= x / i; i++) {
                while (x % i == 0) {
                    x /= i;
                    primes.put(i, primes.getOrDefault(i, 0) + 1);
                }
            }

            if(x > 1) primes.put(x, primes.getOrDefault(x, 0) + 1);
        }

        

        long res = 1; // 这里注意res，t必须是long类型的，否则会越界
        for(Integer p : primes.keySet()) {
            int a = primes.get(p);
            long t = 1;
            while (a-- > 0) {
                t = (t * p + 1) % mod;
            }
            res = res * t % mod;
        }

        System.out.println(res);
    }
}
```



**算法模板**

```cpp
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

#### 4.1.2.3.欧几里得

又叫做辗转相除法

![image-20211107105155686](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211107105155686.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 最大公约数
 */
public class GreatestCommonDivisor {

    private static int gcd(int a, int b) {
        return b > 0 ? gcd(b, a % b) : a;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        while (n-- > 0) {
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(gcd(a, b));
        }
    }
}
```

**算法模板**

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

## 4.2.数学知识（二）

### 4.2.1.欧拉函数

![image-20211108145154913](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108145154913.png)

![image-20211108093417432](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108093417432.png)

#### 4.2.1.1欧拉函数

**证明过程**

![image-20211108093829628](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108093829628.png)

![image-20211108093853806](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108093853806.png)

**代码实现**

```java
package com.axuan.chapter4.demo01;

import java.util.Scanner;

/**
 * 欧拉函数
 */
public class TheEulerFunction {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        while (n-- > 0) {
            int a = in.nextInt();

            int res = a;
            for (int i = 2; i <= a / i; i++) {
                if (a % i == 0) {
                    // res = res * (1 - 1 / i); // 这里是不能用小数计算的，因此要做化简
                    res = res / i * (i - 1);
                    while (a % i == 0)
                        a /= i;
                }
            }

            if (a > 1)
                res = res / a * (a - 1);

            System.out.println(res);
        }
    }
}
```

**算法模板**

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

#### 4.2.1.2.筛法求欧拉函数

当i%pj==0时，

phi[i]里面已经有了(1-1/primes[j])，因此不需要再乘上了

![image-20211108150448754](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108150448754.png)

当i%pj!=0时，

![image-20211108150919258](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108150919258.png)

**代码实现**

```java
package com.axuan.chapter4.demo02;

import java.util.Scanner;

/**
 * 筛法求欧拉函数
 */
public class ScreenCalcEuler {
    static int N = 1000010;

    static int[] primes = new int[N];
    static int cnt;
    static int[] phi = new int[N];
    static boolean[] st = new boolean[N];

    private static long get_eulers(int n) {
        phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (!st[i]) {
                primes[cnt++] = i;
                phi[i] = i - 1; // 一个质数的欧拉函数是它的值-1，因为质数的约数只有它和它本身，除去自身，剩余的都是与它互质的数。
            }
            for (int j = 0; primes[j] <= n / i; j++) {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) {
                    phi[primes[j] * i] = phi[i] * primes[j];
                    break;
                }
                phi[primes[j] * i] = phi[i] * (primes[j] - 1);
            }
        }
        long res = 0;
        for (int i = 1; i <= n; i++) {
            res += phi[i];
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        System.out.println(get_eulers(n));
    }
}
```

**算法模板**

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```





**欧拉定理**

![image-20211108152612346](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108152612346.png)

**证明过程**

![image-20211108153252669](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108153252669.png)

**在欧拉定理的基础上**

如果说，p是质数，则满足：

![image-20211108154034127](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108154034127.png)

### 4.2.2.快速幂

#### 4.2.2.1.快速幂

预处理a的k次幂，将k分解成二进制，进行计算，总体上时间复杂度为logk

![image-20211108154315151](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108154315151.png)

**预处理a的k次幂**

![image-20211108154448295](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108154448295.png)

**例子**

![image-20211108154618720](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108154618720.png)

**代码实现**

```java
package com.axuan.chapter4.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 快速幂
 */
public class FastPower {

    // a ^ k % p
    private static long qmi(long a, long k, long p) {
        long res = 1;
        while (k > 0) {
            if ((k & 1) > 0)
                res = res * a % p;
            k >>= 1;
            a = a * a % p;
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str = reader.readLine().split(" ");
        int n = Integer.parseInt(str[0]);

        String[] s;
        long a, k, p;
        while(n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            k = Integer.parseInt(s[1]);
            p = Integer.parseInt(s[2]);

            System.out.println(qmi(a, k, p));
        }
    }
}
```

**算法模板**

```cpp
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

#### 4.2.2.2.快速幂求逆元

**证明**

![image-20211108171317353](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108171317353.png)

**化简**

由费马定理可得

![image-20211108172634084](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108172634084.png)

**代码实现**

```java
package com.axuan.chapter4.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 快速幂求逆元
 */
public class FastPowerCalcInverrrseElement {
    // a ^ k % p
    private static long qmi(long a, long k, long p) {
        long res = 1;
        while (k > 0) {
            if ((k & 1) > 0)
                res = res * a % p;
            k >>= 1;
            a = a * a % p;
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] str = reader.readLine().split(" ");
        int n = Integer.parseInt(str[0]);

        String[] s;
        long a, p;
        while (n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            p = Integer.parseInt(s[1]);

            long res = qmi(a, p - 2, p);
            if(a % p > 0) System.out.println(res); // a,p不互质，则没有逆元
            else System.out.println("impossible");
        }
    }
}
```

### 4.2.3.扩展欧几里得算法

#### 4.2.3.1.扩展欧几里得算法

![image-20211108190934459](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108190934459.png)

**图示**

当b=0时，

![image-20211108191621000](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108191621000.png)

b!=0时

![image-20211108192611088](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108192611088.png)

其对应的所有的解

![image-20211108194546168](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108194546168.png)

![image-20211108194619446](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108194619446.png)

**代码实现**

```java
// package com.axuan.chapter4.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 扩展欧几里得算法
 */
public class Main {

    static int x, y;

    private static int exgcd(int a, int b) {
        if (b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        int d = exgcd(b, a % b);
        int tmp = x;
        x = y;
        y = tmp - a / b * x;
        return d;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        int n = Integer.parseInt(sArr[0]);

        String[] s;
        int a, b;
        while (n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);

            exgcd(a, b);

            System.out.println(x + " " + y);
        }
    }
}
```

**算法模板**

```cpp
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}

```

#### 4.2.3.2.线性同余方程

![image-20211108194900881](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108194900881.png)

**图示**

![image-20211108194954325](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211108194954325.png)



![image-20211109152746423](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211109152746423.png)

**代码实现**

```java
package com.axuan.chapter4.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
/**
 * 线性同余方程
 */
public class LinearCongruenceEquation {
    static int x, y;

    private static int exgcd(int a, int b) {
        if (b == 0) {
            x = 1;
            y = 0;
            return a;
        }
        int d = exgcd(b, a % b);
        int tmp = x;
        x = y;
        y = tmp - a / b * y;
        return d;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        int n = Integer.parseInt(sArr[0]);

        String[] s;
        int a, b, m;
        while (n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            m = Integer.parseInt(s[2]);
            
            int d = exgcd(a, m);

            if(b % d > 0 ) System.out.println("impossible");
            else System.out.println((long) x * (b / d) % m);

        }
    }
}
```



## 4.3.Week6-习题课

### 4.3.1.中国剩余定理

![image-20211109084542394](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211109084542394.png)

**例子**

![image-20211109194007167](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211109194007167.png)

**推导过程**

![image-20211109161429106](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211109161429106.png)

**代码实现**

```java
package com.axuan.chapter4.test01;

import java.util.Scanner;

/**
 * 中国剩余定理
 */
public class ChineseRemainderTheorem {
    static long k1, k2;

    private static long exgcd(long a, long b) {
        if(b == 0) {
            k1 = 1;
            k2 = 0;
            return a;
        }

        long d = exgcd(b, a % b);
        long tmp = k1;
        k1 = k2;
        k2 = tmp - (a / b) * k1;
        return d;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        boolean has_answer = true;
        long a1 = in.nextLong();
        long m1 = in.nextLong();

        for (int i = 0; i < n - 1; i++) {

            long a2 = in.nextLong();
            long m2 = in.nextLong();

            long d = exgcd(a1, a2);
            if ((m2 - m1) % d  != 0) {
                has_answer = false;
                break;
           } 

           k1 *= (m2 - m1) / d;
           long t = a2 / d;
           k1 = (k1 % t + t) % t;

           m1 = a1 * k1 + m1;
           a1 = Math.abs(a1 / d * a2);
        }

        if (has_answer) {
            System.out.println((m1 % a1 + a1) % a1);
        }else {
            System.out.println("-1");
        }
    }
}
```

## 4.4.数学知识（三）

### 4.4.1.高斯消元

![image-20211110145714292](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110145714292.png)

**例子**

![image-20211110145741867](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110145741867.png)

**特点**

![image-20211110150016057](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110150016057.png)

![image-20211110150104257](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110150104257.png)

**过程**

![image-20211110150239368](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110150239368.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.util.Scanner;

public class GaussElimination{
    static int N = 110;
    static int n;
    static double eps = 0.000001;

    static double[][] a = new double[N][N];

    private static int gauss() {
        int c, r;
        // 遍历每一列
        for(c = 0, r = 0; c < n; c++) {
            int t = r;
            // 找一列中的最大值
            for (int i = r; i < n; i++) {
                if(Math.abs(a[i][c])  > Math.abs(a[t][c])) { //java中的Math.abs()可以用于浮点数取绝对值
                    t = i;
                } 
            }
            
            // 如果找出的最大值为0，继续下一列寻找fei0的最大值
            if (Math.abs(a[t][c]) < eps) continue;

            // 交换
            for (int i = c; i <= n; i++) {
                double temp = a[t][i];
                a[t][i] = a[r][i];
                a[r][i] = temp;
            }

            // 将当前的非0的第一位数置为1，构造阶梯矩阵的斜边
            // 这里要注意从后往前去更新数据，因为这里变化是根据第一个数变化的，要保持它的数据最后变化或者找个数存一下
            for (int i = n; i >= c; i--) {
                a[r][i] /= a[r][c];
            }

            // 下面一步就是用上面那一行来更新下面的所有行，同样要注意从后往前更新数据
            // 注意只需要对首尾非0的行进行更新就行
            for (int i = r + 1; i < n; i++) {
                if (Math.abs(a[i][c]) > eps) {
                    for (int j = n; j >= c; j--) {
                        a[i][j] -= a[r][j] * a[i][c];
                    }
                }
            }

            // 进行下一行的处理
            r++;
        }

        // 0解或者无穷解
        if (r < n) {
            // 阶梯状，更新不了下面的说明往下的都是0;判断下面每一行的最后结果，如果不是0，说明无解
            for (int i = r; i < n; i++) {
                if (Math.abs(a[i][n]) > eps) {
                    return 2; // 无解
                }
            }

            return 1; // 有无穷多组解
        }

        // 处理唯一解，从下往上得出解
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                a[i][n] -= a[i][j] * a[j][n]; //a[j][n]这里的横坐标为j是因为需要从这一行往下清空干净
            }
        }

        // 唯一解
        return 0;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n + 1; j++) {
                a[i][j] = in.nextDouble();
            }
        }

        int t = gauss();
        if (t == 0) {
            for (int i = 0; i < n; i++) {
                System.out.println(String.format("%.2f", a[i][n]));
            }
        } else if (t == 1) {
            System.out.println("Infinite group solutions");
        } else {
            System.out.println("No solution");
        }
    }
}
```

**算法模板**

```cpp
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}
```

### 4.4.2.组合数

![image-20211110160614750](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110160614750.png)

#### 4.4.2.1.递归法求组合数

![image-20211110161816517](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110161816517.png)

递推关系式：

![image-20211110160724132](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110160724132.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 组合数1
 */
public class NumberOfCombinations1 {
    static int N = 2010;
    static int mod = (int) (1e9 + 7);

    static int[][] c = new int[N][N];

    private static void init() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j <= i; j++) { // i必须大于等于j
                if (j == 0) // 从i个中挑出0个，有一种方案
                    c[i][j] = 1;
                else
                    c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        int n = Integer.parseInt(sArr[0]);

        init();
        
        String[] s;
        int a, b;
        while (n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            System.out.println(c[a][b]);
        }
    }
}
```

**算法模板**

```cpp
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

#### 4.4.2.2.通过预处理逆元的方式求组合数

![image-20211110161902240](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110161902240.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 组合数2
 */
public class NumberOfCombinations2 {
    static int N = 100010;
    static int mod = (int) (1e9 + 7);

    static int[] fact = new int[N];
    static int[] infact = new int[N];

    private static int qmi(int a, int k, int p) {
        long res = 1;
        while (k > 0) {
            if ((k & 1) > 0)
                res = res * a % p;
            k >>= 1;
            a = (int)((long)a * a % p);
        }
        return (int)res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        int n = Integer.parseInt(sArr[0]);

        fact[0] = infact[0] = 1;
        for (int i = 1; i < N; i++) {
            fact[i] = (int)((long)fact[i - 1] * i % mod);
            infact[i] = (int)((long)infact[i - 1] * qmi(i, mod - 2, mod) % mod);
        }

        String[] s;
        int a, b;
        while (n-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            System.out.println((int)((long)fact[a] * infact[b] % mod * infact[a - b] % mod));
        }

    }
    
}
```

**算法模板**

```cpp
首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```

#### 4.4.2.3.Lucas定理

![image-20211110164159615](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110164159615.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.util.Scanner;

/**
 * 组合数3
 */
public class NumberOfCombinations3 {

    static int p;

    private static long qmi(long a, int k) {
        long res = 1;
        while (k > 0) {
            if ((k & 1) == 1) {
                res = res * a % p;
            }
            k >>= 1;
            a = a * a % p;
        }
        return res;
    }

    private static long C(long a, long b) {
        long res = 1;
        for (long i = 1, j = a; i <= b; i++, j--) {
            res = res * j % p;
            res = res * qmi(i, p - 2) % p;
        }
        return res;
    }

    private static long lucas(long a, long b) {
        if (a < p && b < p)
            return C(a, b);
        return C(a % p, b % p) * lucas(a / p, b / p) % p;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        long a, b;
        while (n-- > 0) {
            a = in.nextLong();
            b = in.nextLong();
            p = in.nextInt();
            System.out.println(lucas(a, b));
        }
    }

}
```

**算法模板**

```cpp
若p是质数，则对于任意整数 1 <= m <= n，有：
    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)

int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

#### 4.4.2.4.分解质因数法求组合数

![image-20211110172121080](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110172121080.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 组合数4
 */
public class NumberOfCombinations4 {
    static int N = 5010;

    static int[] primes = new int[N];
    static int cnt;
    static boolean[] st = new boolean[N];

    static int[] sum = new int[N];

    private static void get_primes(int n) {
        for (int i = 2; i <= n; i++) {
            if (!st[i])
                primes[cnt++] = i;
            for (int j = 0; primes[j] <= n / i; j++) {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0)
                    break;
            }
        }
    }

    private static int get(int n, int p) {
        int res = 0;
        while (n != 0) {
            res += n / p;
            n /= p;
        }
        return res;
    }

    private static List<Integer> mul(List<Integer> a, int b) {
        List<Integer> c = new ArrayList<>();
        int t = 0;
        for (int i = 0; i < a.size(); i++) {
            t += a.get(i) * b;
            c.add(t % 10);
            t /= 10;
        }

        while (t > 0) {
            c.add(t % 10);
            t /= 10;
        }
        return c;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int a = in.nextInt();
        int b = in.nextInt();

        get_primes(a);

        for (int i = 0; i < cnt; i++) {
            int p = primes[i];
            sum[i] = get(a, p) - get(b, p) - get(a - b, p);
        }

        List<Integer> res = new ArrayList<>();
        res.add(1);

        for (int i = 0; i < cnt; i++) {
            for (int j = 0; j < sum[i]; j++) {
                res = mul(res, primes[i]);
            }
        }

        for (int i = res.size() - 1; i >= 0; i--) {
            System.out.print(res.get(i));
        }

    }
}
```

**算法模板**

```cpp
当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：
    1. 筛法求出范围内的所有质数
    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...
    3. 用高精度乘法将所有质因子相乘

int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉


void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}


int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}


vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);


```

#### 4.4.2.5.满足条件的01序列

**例子**

![image-20211110234710886](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110234710886.png)

**图示**

![image-20211110235139188](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211110235139188.png)

**代码实现**

```java
package com.axuan.chapter4.demo03;

import java.util.Scanner;

/**
 * 满足条件的01序列
 */
public class Sequence01 {
    static int mod = (int) (1e9 + 7);

    private static long qmi(long a, long k, long p) {
        long res = 1;
        while (k > 0) {
            if ((k & 1) > 0)
                res = res * a % p;
            k >>= 1;
            a = a * a % p;
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        long a = 2 * n, b = n;
        long res = 1;

        for (long i = a; i > a - b; i--) {
            res = res * i % mod;
        }

        for (long i = 1; i <= b; i++) {
            res = res * qmi(i, mod - 2, mod) % mod;
        }

        res = res * qmi(n + 1, mod - 2, mod) % mod;

        System.out.println(res);
    }
}
```



**算法模板**

```cpp
给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)
```

## 4.4.数学知识（四）

### 4.4.1.容斥原理

![image-20211112163658895](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211112163658895.png)



![image-20211112163745071](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211112163745071.png)



![image-20211112163934560](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211112163934560.png)

#### 4.4.1.1.被整除的数

![image-20211112164142809](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211112164142809.png)



![image-20211112164322256](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211112164322256.png)

**代码实现**

```java
package com.axuan.chapter4.demo04;

import java.util.Scanner;

/**
 * 能被整除的数
 */
public class NumberOfDivisible {
    static int N = 20;
    static int n, m;

    static int[] p = new int[N];

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();

        for (int i = 0; i < m; i++) {
            p[i] = in.nextInt();
        }

        int res = 0;
        // 枚举从1到1111...（m个1）的每一个集合状态，（至少选中一个集合）
        for (int i = 1; i < 1 << m; i++) {
            long t = 1, cnt = 0; // t表示选中集合对应质数的乘积 ,cnt表示选中的集合数量
            
            // 枚举当前状态的每一位
            for (int j = 0; j < m; j++) {
                // 选中一个集合
                if ((i >> j & 1) > 0) {
                    // 乘积大于n，则n/t=0,跳出这轮循环
                    if(t * p[j] > n) {
                        t = -1;
                        break;
                    }
                    cnt++;  // 有一个1，集合数量+1
                    t *= p[j];
                }
            }

            if (t != -1) {
                if (cnt % 2 > 0) res += n / t; // 选中奇数个集合，则系数应该是1,n / t为当前这种状态的集合数量
                else res -= n / t; // 反之则为-1
            }
        }

        System.out.println(res);
    }
    
}
```



### 4.4.2.博弈论

#### 4.4.2.1.NIM游戏

![image-20211113165229831](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113165229831.png)

![image-20211113093511356](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113093511356.png)

**题解**

![image-20211113094506322](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113094506322.png)

**代码实现**

```java
package com.axuan.chapter4.demo04;

import java.util.Scanner;

public class NimGame {
    
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        int res = 0;
        while (n-- > 0) {
            int x = in.nextInt();
            res ^= x;
        }

        if(res > 0) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

#### 4.4.2.2.集合NIM游戏

![image-20211114105447492](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114105447492.png)

![image-20211113094707452](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113094707452.png)



![image-20211113094806959](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113094806959.png)

**图示**

![image-20211113094915046](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113094915046.png)

**代码实现**

```java
package com.axuan.chapter4.demo04;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * 集合NIM游戏
 */
public class CollectionNIM {
    static int N = 110, M = 10010;

    static int n, m;
    static int[] s = new int[N];
    static int[] f = new int[M];

    private static int sg(int x) { // sg值指的是，有向图中，一个点的下级点sg值中，最小的不存在的值，就是这个点的sg值，终点的sg值是0
        if (f[x] != -1) return f[x]; // 算是做优化，将已经算好的sg值保存，下次见到，不必重新计算

        Set<Integer> S = new HashSet<>();
        for (int i = 0; i < m; i++) { // 枚举每一步的选法
            int sum = s[i];
            if (x >= sum) S.add(sg(x - s[i])); // 若这一步可以走，将下级点的sg值加入集合
        }
        for (int i = 0; ; i++) { // 在集合中找，最小的不存在的值
            if(!S.contains(i)) {
                return f[x] = i; // 找到，保存，返回
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        m = in.nextInt();
        for (int i = 0; i < m; i++) {
            s[i] = in.nextInt();
        }
        n = in.nextInt();

        Arrays.fill(f, -1);

        int res = 0;
        for (int i = 0; i < n; i++) {
            int x = in.nextInt();
            res ^= sg(x); // 将每一堆石子sg值异或起来
        }

        if (res > 0) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

**算法概念**

![image-20211113165250632](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211113165250632.png)

## 4.5.Week7-习题课

### 4.5.1.高斯消元—高斯消元异或线性方程组

![image-20211114094104919](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114094104919.png)



![image-20211114094149087](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114094149087.png)

**代码实现**

```java
package com.axuan.chapter4.test02;

import java.util.Scanner;

/**
 * 高斯消元异或解线性方程组
 */
public class GaussXOR {
    static int N = 110;
    static int n;

    static int[][] a = new int[N][N];

    private static int gauss() {
        int r, c;
        for (r = 0, c =  0; c < n; c++) {
            int t = r;
            for (int i = r; i < n; i++) {
                if (a[i][c] == 1) {
                    t = i;
                    break;
                }
            }

            if (a[t][c] == 0) continue;

            for (int i = c; i <= n; i++) {
                int temp = a[t][i];
                a[t][i] = a[r][i];
                a[r][i] = temp;
            }

            for (int i = r + 1; i < n; i++) {
                if (a[i][c] == 1) {
                    for (int j = c; j <= n; j++) {
                        a[i][j] ^= a[r][j];
                    }
                }
            }

            r++;
        }

        if (r < n) {
            for (int i = r; i < n; i++) {
                if (a[i][n] == 1) {
                    return 2;
                }
            }
            return 1;
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                a[i][n] ^= a[i][j] & a[j][n];
            }
        }

        return 0;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n + 1; j++) {
                a[i][j] = in.nextInt();
            }
        }

        int res = gauss();

        if (res == 0) {
            for (int i = 0; i < n; i++) {
                System.out.println(a[i][n]);
            }
        } else if (res == 1) {
            System.out.println("Multiple sets of solutions");
        } else {
            System.out.println("No solution");
        }
    }
}
```

### 4.5.2.NIM游戏

#### 4.5.2.1.台阶NIM游戏

![image-20211114100255812](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114100255812.png)



![image-20211114100422155](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114100422155.png)

**题解**

![image-20211114105924583](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114105924583.png)



**代码实现**

```java
package com.axuan.chapter4.test02;

import java.util.Scanner;

/**
 * 台阶Nim游戏
 */
public class StepNIM {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        int res = 0;
        for (int i = 1; i <= n; i++) {
            int x = in.nextInt();
            if (i % 2 == 1) res ^= x; // 只对奇数级台阶做运算
        }

        if (res > 0) System.out.println("Yes");
        else System.out.println("No");
    }
}
```



#### 4.5.2.2.拆分NIM游戏

![image-20211114101121305](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114101121305.png)



![image-20211114101222730](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211114101222730.png)

**代码实现**

```java
// package com.axuan.chapter4.test02;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * 拆分NIM游戏
 */
public class Main {
    static int N = 110;

    static int[] f = new int[N];

    private static int sg(int x) {
        if (f[x] != -1) return f[x];

        Set<Integer> S = new HashSet<>();

        for (int i = 0; i < x; i++) {
            for (int j = 0; j <= i; j++) { // j <= i是为了避免与之前的情况重复
                S.add(sg(i) ^ sg(j));
            }
        }

        // mex操作
        for (int i = 0; ; i++) {
            if (!S.contains(i))
                return f[x] = i;
        }

    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();

        Arrays.fill(f, -1);

        int res = 0;
        for (int i = 0; i < n; i++) {
            int x = in.nextInt();
            res ^= sg(x);
        }

        if (res > 0) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

