# 3.搜索与图论

## 3.1.搜索与图论（一）

![image-20211022110008646](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022110008646.png)

**DFS和BFS之间的区别**

![image-20211022110045888](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022110045888.png)

![image-20211022110157424](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022110157424.png)

### 3.1.1.DFS

#### 3.1.1.1.排列数字



![image-20211022110624516](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022110624516.png)

![image-20211022110743415](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022110743415.png)

```java
package com.axuan.chapter3.demo01;

import java.util.Scanner;

public class ArrangementOfDigital {

    static int N = 10;
    static int[] path = new int[N];
    static boolean[] st = new boolean[N];
    static int n;

    private static void dfs(int u) {
        if (u == n) {
            for (int i = 0; i < n; i++) {
                System.out.print(path[i] + " ");
            }
            System.out.println();
            return;
        }

        for (int i = 1; i <= n; i++) {
            if (!st[i]) {
                path[u] = i;
                st[i] = true;
                dfs(u + 1);
                st[i] = false;
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        dfs(0);
    }
}
```



#### 3.1.1.2.n皇后问题

![image-20211022113307301](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211022113307301.png)

**第一种**

```java
package com.axuan.chapter3.demo01;

import java.util.Scanner;

/**
 * n皇后问题
 */
public class NQueen {

    static int N = 20;
    static char[][] g;
    static boolean[] col = new boolean[N];
    static boolean[] dg = new boolean[N];
    static boolean[] udg = new boolean[N];
    static int n;

    private static void dfs(int u) {
        if (u == n) {
            for (int i = 0; i < n; i++) {
                System.out.println(g[i]);
            }
            System.out.println();
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!col[i] && !dg[u + i] && !udg[i - u + n]) {
                g[u][i] = 'Q';
                col[i] = dg[u + i] = udg[-u + i + n] = true;
                dfs(u + 1);
                col[i] = dg[u + i] = udg[-u + i + n] = false;
                g[u][i] = '.';
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        g = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                g[i][j] = '.';
            }
        }
        dfs(0);
    }
}
```

**第二种**

```java
package com.axuan.chapter3.demo01;

import java.util.Scanner;

/**
 * n皇后问题(第二种解法)
 */
public class NQueen2 {

    static int N = 20;
    static char[][] g;
    static boolean[] row = new boolean[N];
    static boolean[] col = new boolean[N];
    static boolean[] dg = new boolean[N];
    static boolean[] udg = new boolean[N];
    static int n;

    private static void dfs(int x, int y, int s) {
        if (y == n) {
            y = 0;
            x++;
        }

        if (x == n) {
            if (s == n) {
                for (int i = 0; i < n; i++) {
                    System.out.println(g[i]);
                }
                System.out.println();
            }
            return;
        }

        // 不放皇后
        dfs(x, y + 1, s);

        // 放皇后
        if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n]) {
            g[x][y] = 'Q';
            row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
            dfs(x, y + 1, s + 1);
            row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
            g[x][y] = '.';
        }
    }

    public static void main(String[] args) throws Exception {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        g = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                g[i][j] = '.';
            }
        }
        dfs(0, 0, 0);
    }
}
```

### 3.1.2.BFS

![image-20211023203902934](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211023203902934.png)

#### 3.1.2.1.走迷宫

```java
package com.axuan.chapter3.demo01;

import java.util.Scanner;

/**
 * 走迷宫
 */
public class Mazes {
    static int N = 110;
    static int n, m;
    static int[][] g = new int[N][N];
    static int[][] d = new int[N][N];
    static Pair[] q = new Pair[N * N];
    // static Pair[][] prev = new Pair[N][N];

    private static int bfs() {
        int hh = 0, tt = 0;
        q[0] = new Pair(0, 0);
        

        int[] dx = {-1, 0, 1, 0};
        int[] dy = {0, 1, 0, -1};

        while (hh <= tt) {
            Pair t = q[hh++];

            for (int i = 0; i < 4; i++) {
                int x = t.x + dx[i];
                int y = t.y + dy[i];
                if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == 0) {
                    d[x][y] = d[t.x][t.y] + 1;
                    // prev[x][y] = t;
                    q[++tt] = new Pair(x, y);
                }
            }
        }
        
        // int x = n - 1, y = m- 1;
        // while(x != 0 || y != 0) {
        //     System.out.println(x + " " + y);
        //     Pair p = prev[x][y];
        //     x = p.x;
        //     y = p.y;
        // }

        return d[n - 1][m - 1];
    }
    

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                g[i][j] = in.nextInt();
            }
        }

        System.out.println(bfs());
    }
}
class Pair{
    int x;
    int y;
 
    public Pair(int x,int y) {
        this.x = x;
        this.y = y;
    }
}
```

### 3.1.3.树与图的深度优先遍历

![image-20211023225347269](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211023225347269.png)





**模板**

树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[ a] [b ]  存储边a->b

(2) 邻接表：

```cpp
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

#### 3.1.3.1.树的重心

![image-20211023230732571](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211023230732571.png)

**代码实现**

```java
package com.axuan.chapter3.demo01;

import java.util.Arrays;
import java.util.Scanner;

/**
 * 树的重心
 */
public class CenterOfGravityOfTheTree {
    static int N = 100010; // 数据范围是10的5次方
    static int M = 2 * N; // 以有向图的格式存储无向图，所以每个节点至多对应2n-2条边

    static int n;  // 题目所给的输入，n个节点
    static int[] h = new int[N]; // 邻接表存储树，有n个节点，所以需要n个队列头结点
    static int[] e = new int[M]; // 存储元素
    static int[] ne = new int[M]; // 存储列表的next值
    static int idx; // 单链表指针
    static boolean[] st = new boolean[N];  // 记录节点是否被访问过，访问过则标记为true
    
    static int ans = N; // 表示重心的所有的子树中，最大的子树的结点数目

    // a所对应的单链表中插入b a作为根
    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    // 返回以u为根的子树中节点的个数，包括u节点
    private static int dfs(int u) {
        int res = 0; // 存储 删掉某个节点之后，最大的连通子图节点数\int sum = 1
        st[u] = true; // 标记访问过u节点
        int sum = 1; // 存储 以u为根的树 的节点数，包括u

        // 访问u的每个子节点
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            // 因为每个节点的编号都是不一样的，所以 用编号为下标，来标记是否被访问过
            if (!st[j]) {
                int s = dfs(j); // u节点的单棵子树节点数
                res = Math.max(res, s); // 记录最大联通子图的节点数
                sum += s; // 以j为根的树 的节点数
            }
        }
        res = Math.max(res, n - sum); // 选择u节点为重心，最大的 连通子图节点数
        ans = Math.min(ans, res); // 遍历过的假设重心中，最小的最大连通子图的 节点数
        return sum;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        Arrays.fill(h, -1);

        // 树中是不存在环的，对于有n个节点的树，必定是n-1条边
        for (int i = 0; i < n - 1; i++) {
            int a = in.nextInt();
            int b = in.nextInt();
            add(a, b);
            add(b, a);
        }

        dfs(1); // 可以任意选定一个节点开始

        System.out.println(ans);
    }
}
```

**dfs模板**

```cpp
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```



### 3.1.3.树与图的广度优先遍历

#### 3.1.3.4.图中点的层次

![image-20211024163210475](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211024163210475.png)

```java
package com.axuan.chapter3.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 图中点的层次
 */
public class HierarchyOfPointsInTheGraph {
    static int N = 100010;

    static int n, m;
    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int idx;

    static int[] d = new int[N];
    static int[] q = new int[N];

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static int bfs() {
        int hh = 0, tt = 0;
        q[0] = 1;
        
        Arrays.fill(d, -1);

        d[1] = 0;  //存储每个节点离起点的距离，（因为1是所有的起点）

        while (hh <= tt) {
            int t = q[hh++];
        
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if(d[j] == -1) {
                    d[j] = d[t] + 1;
                    q[++tt] = j;
                }
            }
        }

        return d[n]; 

    }
 
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Arrays.fill(h, -1);

        for (int i = 0; i < m; i++) {
            String[] s = reader.readLine().split(" ");
            int a = Integer.parseInt(s[0]);
            int b = Integer.parseInt(s[1]);
            add(a,b);
        }

        System.out.println(bfs());
    }
}
```

**bfs模板**

```cpp
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```



### 3.1.4.拓扑排序

#### 3.1.4.1.有向图的拓扑序列

![image-20211024164846284](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211024164846284.png)

![image-20211024165100396](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211024165100396.png)

```java
package com.axuan.chapter3.demo01;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 有向图的拓扑序列
 */
public class TopologicalSequenceOfDirectedGraphs {
    static int N = 100010;

    static int n, m;
    static int[] h = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int idx;

    static int[] q = new int[N];
    static int[] d = new int[N]; // 用来存储入度

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static boolean topsort() {
        int hh = 0, tt = -1;

        for (int i = 1; i <= n; i++) {
            if (d[i] == 0) {
                q[++tt] = i;
            }
        }

        while (hh <= tt) {
            int t = q[hh++];

            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                d[j]--; // 将这个点的入度减1
                if (d[j] == 0) q[++tt] = j;
            }
        }

        return tt == (n - 1);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Arrays.fill(h, -1);
        
        for (int i = 0; i < m; i++) {
            String[] s = reader.readLine().split(" ");
            int a = Integer.parseInt(s[0]);
            int b = Integer.parseInt(s[1]);
            add(a, b);
            d[b]++;
        } 

        if (topsort()) {
            for (int i = 0; i < n; i++) {
                System.out.print(q[i] + " ");
            }
        } else {
            System.out.println("-1");
        }
    }
    
}
```

**拓扑排序模板**

```cpp
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

## 3.2.Week4-习题课

### 3.2.1.BFS-八数码

![image-20211026112028191](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211026112028191.png)

![image-20211026112123766](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211026112123766.png)

**代码实现**

```java
package com.axuan.chapter3.demo02;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;

/**
 * 八数码
 */
public class EightDigital {

    private static int bfs(String start) {
        String end = "12345678x";

        Queue<String> q = new LinkedList<>();
        Map<String, Integer> d = new HashMap<>();

        q.offer(start);
        d.put(start, 0);

        int[] dx = { -1, 0, 1, 0 };
        int[] dy = { 0, 1, 0, -1 };

        while (!q.isEmpty()) {
            String t = q.poll();

            if(t.equals(end)) return d.get(t);

            // 状态转移

            int k = t.indexOf('x');
            int x = k / 3, y = k % 3;
            for (int i = 0; i < 4; i++) {
                int a = x + dx[i], b = y + dy[i];
                if (a >= 0 && a < 3 && b >= 0 && b < 3) {
                    char[] arr = t.toCharArray();
                    swap(arr, k, a * 3 + b);
                    String str = new String(arr);
                    if (!d.containsKey(str)) {
                        d.put(str, d.get(t) + 1);
                        q.offer(str);
                    }
                }
            }
        }
        return -1;
    }

    private static void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        StringBuffer start = new StringBuffer("");
        for (int i = 0; i < 9; i++) {
            String c = in.next();
            start.append(c);
        }

        System.out.println(bfs(start.toString()));
    }

}
```

## 3.3.搜索与图论（二）

![image-20211030222850680](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211030222850680.png)

朴素Dijkstra算法是针对于稠密图的，而对优化版的是针对于稀疏图的。

### 3.3.1.朴素Dijkstra算法

![image-20211030223313988](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211030223313988.png)

**代码实现**

```java
package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 朴素Dijkstra算法
 */
public class Dijkstra {
    static int N = 510;

    static int n, m;
    static int[][] g = new int[N][N];
    static int[] d = new int[N];
    static boolean[] st = new boolean[N];

    private static int dijkstra() {
        Arrays.fill(d, 0x3f3f);
        d[1] = 0;

        for (int i = 0; i < n; i++) {
            // 从中选出最小的
            int t = -1;
            for (int j = 1; j <= n; j++) 
                if(!st[j] && (t == -1 || d[t] > d[j]))
                    t = j;
            // 最小的就是已经确定了的
            st[t] = true;

            // 用它来更新其他的边
            for (int j = 1; j <= n; j++) 
                d[j] = Math.min(d[j], d[t] + g[t][j]);
        }

        if (d[n] == 0x3f3f) return -1;
        return d[n];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        for (int i = 0; i < N; i++) {
            Arrays.fill(g[i], 0x3f3f);
        }

        String[] s;
        int a, b, c;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            g[a][b] = Math.min(g[a][b], c); // 可能会有重边，从中选出较小的
        }

        int t = dijkstra();
        System.out.println(t);
    }
    
}
```

**算法模板**

时间复杂是 O(n2+m), n 表示点数，m 表示边数

![image-20211030234127301](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211030234127301.png)

```cpp
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### 3.3.2.堆优化版Dijkstra

![image-20211030234649562](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211030234649562.png)

**代码实现**

```java
// package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * 堆优化版Dijkstra
 */
public class Main {
    static int N = 1000010;

    static int n, m;
    static int[] h = new int[N];
    static int[] w = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int idx;

    static int[] d = new int[N];
    static boolean[] st = new boolean[N];

    private static void add(int a, int b, int c) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

     // 求1号点到n号点的最短路，如果不存在则返回-1
    private static int dijkstra() {
        Arrays.fill(d, 0x3f3f3f3f);
        d[1] = 0;

        //维护当前未在st中标记过且离源点最近的点
        PriorityQueue<PIIs> heap = new PriorityQueue<>();
        heap.offer(new PIIs(0, 1));

        while (heap.size() > 0) {
            //1、找到当前未在s中出现过且离源点最近的点
            PIIs p = heap.poll();

            int ver = p.getSecond(), distance = p.getFirst();
            if (st[ver])
                continue;

             //2、将该点进行标记
            st[ver] = true;

            //3、用t更新其他点的距离
            for (int i = h[ver]; i != -1; i = ne[i]) {
                int j = e[i];
                if (d[j] > distance + w[i]) {
                    d[j] = distance + w[i];
                    heap.offer(new PIIs(d[j], j));
                }
            }
        }
        if (d[n] == 0x3f3f3f3f)
            return -1;
        return d[n];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Arrays.fill(h, -1);
        String[] s;
        int a, b, c;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            add(a, b, c);
        }

        int t = dijkstra();
        System.out.println(t);
    }

}
class PIIs implements Comparable<PIIs> {
    private int first; // 距离值
    private int second; // 点编号

    public int getFirst() {
        return this.first;
    }

    public int getSecond() {
        return this.second;
    }

    public PIIs(int first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public int compareTo(PIIs o) {
        return Integer.compare(first, o.first);
    }
    
}
```

**算法模板**

时间复杂度 O(mlogn), n 表示点数，m 表示边数

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

### 3.3.3.Bellman-ford算法

![image-20211031234539395](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211031234539395.png)

![image-20211101000208682](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211101000208682.png)

![image-20211102170351736](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211102170351736.png)

```java
package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class BellmanFord {
    static int N = 510, M = 100010;
    static int n,m;
    static int k; // 最多经过k条边
    static int[] dist = new int[N];
    static int[] backup = new int[N];
    static Edge[] edges = new Edge[M];

    private static void bellman_ford() {
        Arrays.fill(dist, 0x3f3f3f3f);
        dist[1] = 0;

        for (int i = 0; i < k; i++) {
            backup = Arrays.copyOf(dist, n + 1);
            for (int j = 0; j < m; j++) {
                Edge e = edges[j];
                int a = e.a;
                int b = e.b;
                int w = e.w;
                dist[b] = Math.min(dist[b], backup[a] + w);
            }
        }
        if(dist[n] > (0x3f3f3f3f / 2)) System.out.println("impossible");
        else System.out.println(dist[n]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);
        k = Integer.parseInt(sArr[2]);

        int a, b, w;
        String[] s;
        for (int i = 0; i < m; i++) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            w = Integer.parseInt(s[2]);
            edges[i] = new Edge(a, b, w);
        }

        bellman_ford();
    }
}

class Edge {
    int a;
    int b;
    int w;

    public Edge(int a, int b, int w) {
        this.a = a;
        this.b = b;
        this.w = w;
    }
}
```

**算法模板**

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```

### 3.3.4.spfa算法

![image-20211102170824574](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211102170824574.png)

```java
package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

/**
 * spfa算法
 */
public class Spfa {
    static int N = 100010;;
    static int n, m;
    static int[] h = new int[N];
    static int[] w = new int[N];
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int idx;

    static int[] dist = new int[N];
    static boolean[] st = new boolean[N];

    private static void add(int a, int b, int c) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static void spfa() {
        Arrays.fill(dist, 0x3f3f3f3f);
        dist[1] = 0;

        Queue<Integer> q = new LinkedList<>();
        q.offer(1);
        st[1] = true; // 标记1号点在队列中

        while(q.size() > 0) {
            int t = q.poll();
            st[t] = false;

            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i]; // 获取点编号
                // 若该点被更新过，则加入队列中
                if (dist[j] > dist[t] + w[i]) {
                    dist[j] = dist[t] + w[i];
                    if(!st[j]) {
                        q.offer(j);
                        st[j] = true; // 标记已加入队列
                    }
                }
            }
        }

        if(dist[n] == 0x3f3f3f3f) System.out.println("impossible");
        else System.out.println(dist[n]);
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Arrays.fill(h, -1);

        String[] s;
        int a, b, c;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            add(a, b, c);
        }

        spfa();
    }
    
}
```

**算法模板**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

#### 3.3.4.1.判断负环

![image-20211102202031984](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211102202031984.png)

**代码实现**

```java
package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class JudgeTheNegativeRing {
    static int N = 100010;
    static int n, m;
    static int[] e = new int[N];
    static int[] ne = new int[N];
    static int[] h = new int[N];
    static int[] w = new int[N];
    static int idx;

    static int[] dist = new int[N];
    static int[] cnt = new int[N];
    static boolean[] st = new boolean[N];

    private static void add(int a, int b, int c ) {
        e[idx] = b;
        w[idx] = c;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static boolean spfa() {
        Queue<Integer> q = new LinkedList<>();

        for (int i = 1; i <= n; i++) {
            st[i] = true;
            q.offer(i);
        }

        while(q.size() > 0) {
            int t = q.poll();

            st[t] = false;

            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if(dist[j] > dist[t] + w[i]) {
                    dist[j] = dist[t] + w[i];
                    cnt[j] = cnt[t] + 1;

                    if(cnt[j] >= n) return true;
                    if(!st[j]) {
                        q.offer(j);
                        st[j] = true;
                    }
                }

            }
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);
        Arrays.fill(h, -1);

        String[] s;
        int a, b, c;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            add(a, b, c);
        }

        if(spfa()) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

**算法模板**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```

### 3.3.5.Floyd算法

![image-20211102204507830](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211102204507830.png)

**代码实现**

```java
package com.axuan.chapter3.demo02;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * Floyd算法
 */
public class Floyd {
    static int N = 210, INF = (int)1e9;
    static int n, m, Q;
    static int[][] d = new int[N][N];

    private static void floyd() {
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);
        Q = Integer.parseInt(sArr[2]);

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if(i == j) d[i][j] = 0;
                else d[i][j] = INF;
            }
        }

        String[] s;
        int a, b, c;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            d[a][b] = Math.min(d[a][b], c);
        }

        floyd();

        while(Q-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            if(d[a][b] > INF /2 ) System.out.println("impossible");
            else System.out.println(d[a][b]);
        }
    }
}
```

**算法模板**

```cpp
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

## 3.4.搜索与图论（三）

### 3.4.1.最小生成树

![image-20211105151541120](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105151541120.png)

#### 3.4.1.1.朴素Prim算法

![image-20211105152019407](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105152019407.png)

![image-20211105160746703](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105160746703.png)

**代码实现**

```java
package com.axuan.chapter3.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Prim {
    static int N = 510;
    static int INF = 0x3f3f3f3f;

    static int n, m;
    static int[][] g = new int[N][N];
    static int[] dist = new int[N];
    static boolean[] st = new boolean[N];

    private static int prim() {
        Arrays.fill(dist, INF);

        int res = 0;
        for (int i = 0; i < n; i++) {
            int t = -1;
            for (int j = 1; j <= n; j++) {
                if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                    t = j;
                }
            }

            if (i > 0 && dist[t] == INF)
                return INF;
            if (i > 0)
                res += dist[t]; // 这一步的提前是为了防止避免将自环加上到计算中去

            for (int j = 1; j <= n; j++) {
                dist[j] = Math.min(dist[j], g[t][j]); // 更新的是点到集合的距离
            }

            st[t] = true;
        }

        return res;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        for (int i = 0; i <= n; i++) {
            Arrays.fill(g[i], INF);
        }

        String[] s;
        int a, b, c;
        while(m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            c = Integer.parseInt(s[2]);
            g[a][b] = g[b][a] =  Math.min(g[a][b], c);
        }

        int t = prim();

        if (t == INF) System.out.println("impossible");
        else System.out.println(t);
    }
}
```

**算法模板**

```cpp
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```

#### 3.4.1.2.堆优化版Prim算法

![image-20211105161204636](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105161204636.png)

#### 3.4.1.3.Kruskal算法

![image-20211105161302087](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105161302087.png)

**代码实现**

```java
package com.axuan.chapter3.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;

public class Kruskal {
    static int N = 200010;

    static int n, m;
    static int[] p = new int[N];

    static Comparator<Edge> cmp  = new Comparator<Edge>() {
        // 将两边的权值按照从小到大排序
        @Override
        public int compare(Edge o1, Edge o2) {
            return o1.c - o2.c;
        }
    };


    private static int find(int x) {
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Edge[] edges = new Edge[m];

        String[] s;
        for (int i = 0; i < m; i++) {
            s = reader.readLine().split(" ");
            int a = Integer.parseInt(s[0]);
            int b = Integer.parseInt(s[1]);
            int c = Integer.parseInt(s[2]);
            edges[i] = new Edge(a, b, c);
        }

        Arrays.sort(edges, cmp);

        for (int i = 1; i <= n; i++) {
            p[i] = i;
        }

        int res = 0, cnt = 0;
        for (int i = 0; i < m; i++) {
            Edge e = edges[i];
            int a = e.a;
            int b = e.b;
            int c = e.c;

            a = find(a);
            b = find(b);
            if(a != b) {
                p[a] = b;
                res += c;
                cnt++;
            }
        }

        if(cnt < n - 1) System.out.println("impossible");
        else System.out.println(res);
    }
}
class Edge{
    int a;
    int b;
    int c;

    public Edge(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
```

**算法模板**

```cpp
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```

### 3.4.2.二分图

![image-20211105164714381](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105164714381.png)

#### 3.4.2.1.染色法

![image-20211105164744141](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105164744141.png)

**代码实现**

```java
package com.axuan.chapter3.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 染色法
 */
public class Dyeing {
    static int N = 100010, M = 200010;
    static int n, m;

    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx;

    static int[] color = new int[N];

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    // 染色成功返回true
    private static boolean dfs(int u, int c) {
        color[u] = c;

        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (color[j] == 0) {
                if (!dfs(j, 3 - c))
                    return false; // 一个端点染成1，另一个就染成2
            } else if (color[j] == c)
                return false; // 一条边的两个端点的颜色，如果相等，返回true
        }

        return true;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n = Integer.parseInt(sArr[0]);
        m = Integer.parseInt(sArr[1]);

        Arrays.fill(h, -1);

        String[] s;
        int a, b;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            add(a, b);
            add(b, a);
        }

        boolean flag = true;
        for (int i = 1; i <= n; i++) {
            if (color[i] == 0) {
                if (!dfs(i, 1)) {
                    flag = false;
                    break;
                }
            }
        }

        if (flag)
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}
```

**算法模板**

```cpp
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

#### 3.4.2.2.匈牙利算法

![image-20211105171429366](https://moon-axuan.oss-cn-beijing.aliyuncs.com/axuan/images/typora/image-20211105171429366.png)

**代码实现**

```java
package com.axuan.chapter3.demo03;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
 * 匈牙利算法
 */
public class Hungary {
    static int N = 510, M = 100010;
    static int n1, n2, m;

    static int[] h = new int[N];
    static int[] e = new int[M];
    static int[] ne = new int[M];
    static int idx;

    static int[] match = new int[N];
    static boolean[] st = new boolean[N];

    private static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static boolean find(int x) {
        for (int i = h[x]; i != -1; i = ne[i]) {
            int j = e[i];
            if (!st[j]) {
                st[j] = true;
                if (match[j] == 0 || find(match[j])) { // 如果这个女生没有心仪的，或者喜欢这个女生的男生可以找到下家的话,就把这个女生给这个男生
                    match[j] = x;
                    return true;
                }
            }
        }

        return false;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        String[] sArr = reader.readLine().split(" ");
        n1 = Integer.parseInt(sArr[0]);
        n2 = Integer.parseInt(sArr[1]);
        m = Integer.parseInt(sArr[2]);

        Arrays.fill(h, -1);

        String[] s;
        int a, b;
        while (m-- > 0) {
            s = reader.readLine().split(" ");
            a = Integer.parseInt(s[0]);
            b = Integer.parseInt(s[1]);
            add(a, b);
        }

        int res = 0;
        for (int i = 1; i <= n1; i++) {  // 匹配的时候只看左边就可以了
            Arrays.fill(st, false);
            if(find(i)) res++;
        }

        System.out.println(res);
    }
}
```

**算法模板**

```cpp
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

